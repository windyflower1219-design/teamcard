<!DOCTYPE html>
<html lang="ko">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Military Doctrine Knowledge Graph</title>
    <link rel="manifest" href="manifest.json">
    <meta name="theme-color" content="#1a1a1a">

    <script>
        // Service Worker Registration
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('./sw.js')
                    .then(reg => console.log('âœ… SW registered!', reg))
                    .catch(err => console.log('âŒ SW registration failed:', err));
            });
        }
    </script>

    <!-- PDF.js Library -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <script>
        // Set PDF.js worker
        if (typeof pdfjsLib !== 'undefined') {
            pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
        }
    </script>

    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --bg-dark: #1a1a1a;
            --bg-darker: #0d0d0d;
            --bg-card: #2d2d2d;
            --military-green: #4a5f4a;
            --military-green-hover: #5a7a5a;
            --accent-orange: #ff6b35;
            --text-primary: #e0e0e0;
            --text-secondary: #a0a0a0;
            --border-color: #3a3a3a;
            --success: #4CAF50;
            --warning: #FFC107;
            --danger: #F44336;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: var(--bg-dark);
            color: var(--text-primary);
            overflow: hidden;
        }

        .app-container {
            display: flex;
            height: 100vh;
        }

        /* Sidebar */
        .sidebar {
            width: 300px;
            background: var(--bg-darker);
            border-right: 1px solid var(--border-color);
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .sidebar-header {
            padding: 20px;
            background: var(--military-green);
            border-bottom: 2px solid var(--accent-orange);
        }

        .sidebar-header h1 {
            font-size: 1.2rem;
            font-weight: 600;
            margin-bottom: 5px;
        }

        .sidebar-header .doc-info {
            font-size: 0.75rem;
            color: rgba(255, 255, 255, 0.7);
        }

        .upload-section {
            padding: 15px;
            border-bottom: 1px solid var(--border-color);
        }

        .upload-btn {
            width: 100%;
            padding: 10px;
            background: var(--military-green);
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-weight: 600;
            transition: background 0.2s;
        }

        .upload-btn:hover {
            background: var(--military-green-hover);
        }

        .paragraph-list {
            flex: 1;
            overflow-y: auto;
            padding: 10px;
        }

        .paragraph-item {
            padding: 12px;
            margin-bottom: 8px;
            background: var(--bg-card);
            border-left: 3px solid transparent;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .paragraph-item:hover {
            background: #3a3a3a;
            border-left-color: var(--military-green);
        }

        .paragraph-item.active {
            background: var(--military-green);
            border-left-color: var(--accent-orange);
        }

        .paragraph-item .number {
            font-weight: 700;
            color: var(--accent-orange);
            font-size: 0.9rem;
        }

        .paragraph-item .title {
            font-size: 0.85rem;
            margin-top: 4px;
            color: var(--text-secondary);
        }

        .paragraph-item .progress {
            margin-top: 8px;
            height: 4px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 2px;
            overflow: hidden;
        }

        .paragraph-item .progress-bar {
            height: 100%;
            background: var(--success);
            transition: width 0.3s;
        }

        /* Main Content */
        .main-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .main-header {
            padding: 20px 30px;
            background: var(--bg-card);
            border-bottom: 1px solid var(--border-color);
        }

        .main-header h2 {
            font-size: 1.5rem;
            margin-bottom: 5px;
        }

        .main-header .subtitle {
            font-size: 0.9rem;
            color: var(--text-secondary);
        }

        .progress-summary {
            margin-top: 15px;
            display: flex;
            gap: 20px;
        }

        .progress-stat {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .progress-stat .label {
            font-size: 0.85rem;
            color: var(--text-secondary);
        }

        .progress-stat .value {
            font-weight: 700;
            color: var(--success);
        }

        /* Tabs */
        .tabs {
            display: flex;
            gap: 0;
            padding: 0 30px;
            background: var(--bg-card);
            border-bottom: 1px solid var(--border-color);
        }

        .tab {
            padding: 12px 20px;
            background: transparent;
            border: none;
            color: var(--text-secondary);
            cursor: pointer;
            font-weight: 600;
            border-bottom: 2px solid transparent;
            transition: all 0.2s;
        }

        .tab:hover {
            color: var(--text-primary);
            background: rgba(255, 255, 255, 0.05);
        }

        .tab.active {
            color: var(--accent-orange);
            border-bottom-color: var(--accent-orange);
        }

        /* Content Area */
        .content-area {
            flex: 1;
            overflow-y: auto;
            padding: 30px;
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        /* Sentences Tab */
        .sentence-item {
            padding: 15px;
            margin-bottom: 12px;
            background: var(--bg-card);
            border-radius: 6px;
            border-left: 3px solid var(--border-color);
            transition: all 0.2s;
        }

        .sentence-item:hover {
            background: #3a3a3a;
        }

        .sentence-item.completed {
            opacity: 0.6;
            border-left-color: var(--success);
        }

        .sentence-header {
            display: flex;
            align-items: flex-start;
            gap: 12px;
        }

        .sentence-checkbox {
            width: 20px;
            height: 20px;
            margin-top: 2px;
            cursor: pointer;
            accent-color: var(--military-green);
        }

        .sentence-id {
            font-weight: 700;
            color: var(--accent-orange);
            min-width: 30px;
        }

        .sentence-text {
            flex: 1;
            line-height: 1.6;
        }

        .sentence-text.completed {
            text-decoration: line-through;
        }

        /* Keywords Tab */
        .keyword-item {
            padding: 12px 15px;
            margin-bottom: 10px;
            background: var(--bg-card);
            border-radius: 6px;
            display: flex;
            align-items: center;
            gap: 12px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .keyword-item:hover {
            background: #3a3a3a;
            transform: translateX(5px);
        }

        .keyword-color {
            width: 20px;
            height: 20px;
            border-radius: 4px;
            flex-shrink: 0;
        }

        .keyword-text {
            flex: 1;
            font-weight: 500;
        }

        .keyword-badges {
            display: flex;
            gap: 4px;
        }

        .keyword-badge {
            padding: 2px 8px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            font-size: 0.75rem;
            color: var(--text-secondary);
        }

        /* Claims Tab */
        .claim-item {
            padding: 15px;
            margin-bottom: 15px;
            background: var(--bg-card);
            border-radius: 6px;
            border-left: 3px solid var(--warning);
        }

        .claim-item.completed {
            opacity: 0.6;
            border-left-color: var(--success);
        }

        .claim-header {
            display: flex;
            gap: 12px;
            margin-bottom: 10px;
        }

        .claim-checkbox {
            width: 20px;
            height: 20px;
            margin-top: 2px;
            cursor: pointer;
            accent-color: var(--military-green);
        }

        .claim-text {
            flex: 1;
            line-height: 1.6;
            font-weight: 500;
        }

        .claim-evidence {
            margin-left: 32px;
            font-size: 0.85rem;
            color: var(--text-secondary);
        }

        .evidence-badge {
            display: inline-block;
            padding: 2px 6px;
            background: rgba(255, 107, 53, 0.2);
            border-radius: 3px;
            margin-right: 4px;
            color: var(--accent-orange);
            cursor: pointer;
        }

        .evidence-badge:hover {
            background: rgba(255, 107, 53, 0.4);
        }

        /* References Tab */
        .reference-item {
            padding: 15px;
            margin-bottom: 12px;
            background: var(--bg-card);
            border-radius: 6px;
            border-left: 3px solid #2196F3;
        }

        .reference-type {
            font-size: 0.75rem;
            color: #2196F3;
            font-weight: 600;
            text-transform: uppercase;
            margin-bottom: 8px;
        }

        .reference-link {
            color: var(--text-primary);
            text-decoration: none;
            font-weight: 500;
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
            transition: color 0.2s;
        }

        .reference-link:hover {
            color: #2196F3;
        }

        .reference-link::before {
            content: "â†’";
            color: #2196F3;
        }

        .reference-evidence {
            margin-top: 8px;
            font-size: 0.85rem;
            color: var(--text-secondary);
        }

        /* Summary Tab */
        .summary-content {
            background: var(--bg-card);
            padding: 20px;
            border-radius: 6px;
            line-height: 1.8;
        }

        .summary-content h3 {
            color: var(--accent-orange);
            margin-bottom: 15px;
        }

        /* Empty State */
        .empty-state {
            text-align: center;
            padding: 60px 20px;
            color: var(--text-secondary);
        }

        .empty-state svg {
            width: 80px;
            height: 80px;
            margin-bottom: 20px;
            opacity: 0.3;
        }

        .empty-state h3 {
            margin-bottom: 10px;
        }

        /* Scrollbar */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }

        ::-webkit-scrollbar-track {
            background: var(--bg-darker);
        }

        ::-webkit-scrollbar-thumb {
            background: var(--border-color);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: var(--military-green);
        }

        /* Highlight */
        .highlight {
            padding: 2px 4px;
            border-radius: 3px;
            font-weight: 500;
        }

        /* Responsive */
        @media (max-width: 768px) {
            .sidebar {
                width: 250px;
            }

            .content-area {
                padding: 20px;
            }
        }
    </style>
</head>

<body>
    <div class="app-container">
        <!-- Sidebar -->
        <div class="sidebar">
            <div class="sidebar-header">
                <h1>ğŸ“š Doctrine KG</h1>
                <div class="doc-info">Military Knowledge Graph</div>
            </div>

            <div class="upload-section">
                <input type="file" id="jsonUpload" accept=".json" style="display: none;">
                <button class="upload-btn" onclick="document.getElementById('jsonUpload').click()">
                    ğŸ“ Load Doctrine JSON
                </button>
                <input type="file" id="pdfUpload" accept=".pdf" style="display: none;">
                <button class="upload-btn" onclick="document.getElementById('pdfUpload').click()"
                    style="margin-top: 8px; background: var(--military-green);">
                    ğŸ“„ Upload PDF
                </button>
                <button class="upload-btn" onclick="toggleTextInput()" style="margin-top: 8px; background: #3a3a3a;">
                    âœï¸ Paste Text
                </button>
            </div>

            <!-- Text Input Modal -->
            <div id="textInputModal"
                style="display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.8); z-index: 9999; padding: 20px;">
                <div
                    style="background: var(--bg-card); border-radius: 8px; max-width: 800px; margin: 0 auto; padding: 30px; max-height: 90vh; overflow-y: auto;">
                    <h2 style="margin-bottom: 20px; color: var(--accent-orange);">ğŸ“ Paste Doctrine Text</h2>

                    <div style="margin-bottom: 15px;">
                        <label
                            style="display: block; margin-bottom: 5px; color: var(--text-secondary); font-size: 0.9rem;">Paragraph
                            Number:</label>
                        <input type="text" id="paraNumber" placeholder="ì˜ˆ: 3-6"
                            style="width: 100%; padding: 10px; background: var(--bg-dark); border: 1px solid var(--border-color); border-radius: 4px; color: var(--text-primary);">
                    </div>

                    <div style="margin-bottom: 15px;">
                        <label
                            style="display: block; margin-bottom: 5px; color: var(--text-secondary); font-size: 0.9rem;">Paragraph
                            Title:</label>
                        <input type="text" id="paraTitle" placeholder="ì˜ˆ: defense of a linear obstacle"
                            style="width: 100%; padding: 10px; background: var(--bg-dark); border: 1px solid var(--border-color); border-radius: 4px; color: var(--text-primary);">
                    </div>

                    <div style="margin-bottom: 20px;">
                        <label
                            style="display: block; margin-bottom: 5px; color: var(--text-secondary); font-size: 0.9rem;">Paragraph
                            Text:</label>
                        <textarea id="paraText" placeholder="êµë²” í…ìŠ¤íŠ¸ë¥¼ ì—¬ê¸°ì— ë¶™ì—¬ë„£ìœ¼ì„¸ìš”..."
                            style="width: 100%; height: 300px; padding: 15px; background: var(--bg-dark); border: 1px solid var(--border-color); border-radius: 4px; color: var(--text-primary); font-family: inherit; resize: vertical;"></textarea>
                    </div>

                    <div style="display: flex; gap: 10px;">
                        <button onclick="parseAndAddParagraph()"
                            style="flex: 1; padding: 12px; background: var(--military-green); color: white; border: none; border-radius: 4px; cursor: pointer; font-weight: 600;">
                            âœ… Parse & Add
                        </button>
                        <button onclick="toggleTextInput()"
                            style="flex: 1; padding: 12px; background: var(--danger); color: white; border: none; border-radius: 4px; cursor: pointer; font-weight: 600;">
                            âŒ Cancel
                        </button>
                    </div>
                </div>
            </div>

            <!-- PDF Settings Modal -->
            <div id="pdfSettingsModal"
                style="display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.8); z-index: 9999; padding: 20px;">
                <div
                    style="background: var(--bg-card); border-radius: 8px; max-width: 600px; margin: 0 auto; padding: 30px; max-height: 90vh; overflow-y: auto;">
                    <h2 style="margin-bottom: 20px; color: var(--accent-orange);">ğŸ“„ PDF íŒŒì‹± ì„¤ì •</h2>

                    <div id="pdfInfo"
                        style="margin-bottom: 20px; padding: 15px; background: var(--bg-dark); border-radius: 4px; color: var(--text-secondary); font-size: 0.9rem;">
                        <!-- PDF info will be displayed here -->
                    </div>

                    <div style="margin-bottom: 15px;">
                        <label
                            style="display: block; margin-bottom: 5px; color: var(--text-secondary); font-size: 0.9rem;">
                            ğŸ“ íŒŒì‹±í•  í˜ì´ì§€ ë²”ìœ„:
                        </label>
                        <div style="display: flex; gap: 10px; align-items: center;">
                            <input type="number" id="parseStartPage" placeholder="ì‹œì‘" min="1"
                                style="flex: 1; padding: 10px; background: var(--bg-dark); border: 1px solid var(--border-color); border-radius: 4px; color: var(--text-primary);">
                            <span style="color: var(--text-secondary);">~</span>
                            <input type="number" id="parseEndPage" placeholder="ë" min="1"
                                style="flex: 1; padding: 10px; background: var(--bg-dark); border: 1px solid var(--border-color); border-radius: 4px; color: var(--text-primary);">
                        </div>
                        <div style="margin-top: 5px; font-size: 0.8rem; color: var(--text-secondary);">
                            ì˜ˆ: 1 ~ 50 (ë¹„ì›Œë‘ë©´ ì „ì²´ í˜ì´ì§€)
                        </div>
                    </div>

                    <div style="margin-bottom: 20px;">
                        <label
                            style="display: block; margin-bottom: 5px; color: var(--text-secondary); font-size: 0.9rem;">
                            ğŸ“š Glossary í˜ì´ì§€ ë²”ìœ„:
                        </label>
                        <div style="display: flex; gap: 10px; align-items: center;">
                            <input type="number" id="glossaryStartPage" placeholder="ì‹œì‘" min="1"
                                style="flex: 1; padding: 10px; background: var(--bg-dark); border: 1px solid var(--border-color); border-radius: 4px; color: var(--text-primary);">
                            <span style="color: var(--text-secondary);">~</span>
                            <input type="number" id="glossaryEndPage" placeholder="ë" min="1"
                                style="flex: 1; padding: 10px; background: var(--bg-dark); border: 1px solid var(--border-color); border-radius: 4px; color: var(--text-primary);">
                        </div>
                        <div style="margin-top: 5px; font-size: 0.8rem; color: var(--text-secondary);">
                            ì˜ˆ: 200 ~ 210 (ë¹„ì›Œë‘ë©´ ì „ì²´ì—ì„œ ìë™ íƒì§€)
                        </div>
                    </div>

                    <div style="display: flex; gap: 10px;">
                        <button onclick="processPDFWithSettings()"
                            style="flex: 1; padding: 12px; background: var(--military-green); color: white; border: none; border-radius: 4px; cursor: pointer; font-weight: 600;">
                            âœ… íŒŒì‹± ì‹œì‘
                        </button>
                        <button onclick="closePDFSettings()"
                            style="flex: 1; padding: 12px; background: var(--danger); color: white; border: none; border-radius: 4px; cursor: pointer; font-weight: 600;">
                            âŒ ì·¨ì†Œ
                        </button>
                    </div>
                </div>
            </div>

            <!-- Glossary List Modal -->
            <div id="glossaryModal"
                style="display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.8); z-index: 9999; padding: 20px;">
                <div
                    style="background: var(--bg-card); border-radius: 8px; max-width: 800px; margin: 0 auto; padding: 30px; max-height: 90vh; display: flex; flex-direction: column;">
                    <div
                        style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                        <h2 style="color: var(--accent-orange); margin: 0;">ğŸ“š Doctrine Glossary</h2>
                        <button onclick="document.getElementById('glossaryModal').style.display = 'none'"
                            style="background: transparent; border: none; color: var(--text-secondary); font-size: 1.5rem; cursor: pointer;">
                            &times;
                        </button>
                    </div>

                    <div style="margin-bottom: 15px;">
                        <input type="text" id="glossarySearch" placeholder="ğŸ” Search terms..."
                            onkeyup="filterGlossary()"
                            style="width: 100%; padding: 12px; background: var(--bg-dark); border: 1px solid var(--border-color); border-radius: 4px; color: var(--text-primary);">
                    </div>

                    <div id="glossaryListContent" style="flex: 1; overflow-y: auto; padding-right: 10px;">
                        <!-- Glossary items will be populated here -->
                    </div>
                </div>
            </div>

            <div class="paragraph-list" id="paragraphList">
                <!-- Paragraphs will be loaded here -->
            </div>
        </div>

        <!-- Main Content -->
        <div class="main-content">
            <div class="main-header">
                <h2 id="mainTitle">Select a paragraph</h2>
                <div class="subtitle" id="mainSubtitle">Choose from the sidebar</div>
                <div class="progress-summary" id="progressSummary" style="display: none;">
                    <div class="progress-stat">
                        <span class="label">Sentences:</span>
                        <span class="value" id="sentenceProgress">0/0</span>
                    </div>
                    <div class="progress-stat">
                        <span class="label">Claims:</span>
                        <span class="value" id="claimProgress">0/0</span>
                    </div>
                    <div class="progress-stat">
                        <span class="label">Progress:</span>
                        <span class="value" id="overallProgress">0%</span>
                    </div>
                </div>
            </div>

            <div class="tabs">
                <button class="tab active" data-tab="sentences">ğŸ“ Sentences</button>
                <button class="tab" data-tab="keywords">ğŸ”‘ Keywords</button>
                <button class="tab" data-tab="claims">â­ Claims</button>
                <button class="tab" data-tab="references">ğŸ”— References</button>
                <button class="tab" data-tab="metadata">â„¹ï¸ Metadata</button>
                <button class="tab" data-tab="summary">ğŸ“„ Summary</button>
            </div>

            <div class="content-area">
                <!-- Sentences Tab -->
                <div class="tab-content active" id="sentences">
                    <div class="empty-state">
                        <svg fill="currentColor" viewBox="0 0 20 20">
                            <path d="M9 2a1 1 0 000 2h2a1 1 0 100-2H9z"></path>
                            <path fill-rule="evenodd"
                                d="M4 5a2 2 0 012-2 3 3 0 003 3h2a3 3 0 003-3 2 2 0 012 2v11a2 2 0 01-2 2H6a2 2 0 01-2-2V5zm3 4a1 1 0 000 2h.01a1 1 0 100-2H7zm3 0a1 1 0 000 2h3a1 1 0 100-2h-3zm-3 4a1 1 0 100 2h.01a1 1 0 100-2H7zm3 0a1 1 0 100 2h3a1 1 0 100-2h-3z"
                                clip-rule="evenodd"></path>
                        </svg>
                        <h3>No paragraph selected</h3>
                        <p>Load a doctrine JSON and select a paragraph from the sidebar</p>
                    </div>
                </div>

                <!-- Keywords Tab -->
                <div class="tab-content" id="keywords">
                    <div class="empty-state">
                        <h3>No keywords available</h3>
                    </div>
                </div>

                <!-- Claims Tab -->
                <div class="tab-content" id="claims">
                    <div class="empty-state">
                        <h3>No claims available</h3>
                    </div>
                </div>

                <!-- References Tab -->
                <div class="tab-content" id="references">
                    <div class="empty-state">
                        <h3>No references available</h3>
                    </div>
                </div>

                <!-- Metadata Tab -->
                <div class="tab-content" id="metadata">
                    <div class="empty-state">
                        <h3>No metadata available</h3>
                    </div>
                </div>

                <!-- Summary Tab -->
                <div class="tab-content" id="summary">
                    <div class="empty-state">
                        <h3>No summary available</h3>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        let doctrineData = null;
        let currentParagraph = null;
        let glossaryTerms = []; // Store glossary terms from PDF
        let currentPDF = null; // Store current PDF object

        // PDF Upload Handler
        document.addEventListener('DOMContentLoaded', () => {
            document.getElementById('pdfUpload').addEventListener('change', handlePDFUpload);
        });

        async function handlePDFUpload(e) {
            const file = e.target.files[0];
            if (!file) return;

            try {
                const arrayBuffer = await file.arrayBuffer();
                const pdf = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;

                // Store PDF object
                currentPDF = {
                    pdf: pdf,
                    fileName: file.name
                };

                // Show settings modal
                showPDFSettings(pdf);

            } catch (error) {
                alert('âŒ PDF ë¡œë“œ ì˜¤ë¥˜: ' + error.message);
                console.error('PDF Error:', error);
            }
        }

        function showPDFSettings(pdf) {
            const modal = document.getElementById('pdfSettingsModal');
            const infoDiv = document.getElementById('pdfInfo');

            // Display PDF info
            infoDiv.innerHTML = `
                <strong>ğŸ“„ ${currentPDF.fileName}</strong><br>
                ì´ í˜ì´ì§€ ìˆ˜: ${pdf.numPages}
            `;

            // Set default values
            document.getElementById('parseStartPage').value = '1';
            document.getElementById('parseEndPage').value = pdf.numPages;
            document.getElementById('glossaryStartPage').value = '';
            document.getElementById('glossaryEndPage').value = '';

            modal.style.display = 'block';
        }

        function closePDFSettings() {
            document.getElementById('pdfSettingsModal').style.display = 'none';
            currentPDF = null;
            document.getElementById('pdfUpload').value = ''; // Reset file input
        }

        async function processPDFWithSettings() {
            if (!currentPDF) return;

            const parseStart = parseInt(document.getElementById('parseStartPage').value) || 1;
            const parseEnd = parseInt(document.getElementById('parseEndPage').value) || currentPDF.pdf.numPages;
            const glossaryStart = parseInt(document.getElementById('glossaryStartPage').value) || null;
            const glossaryEnd = parseInt(document.getElementById('glossaryEndPage').value) || null;

            // Validate ranges
            if (parseStart < 1 || parseEnd > currentPDF.pdf.numPages || parseStart > parseEnd) {
                alert('âŒ ì˜ëª»ëœ í˜ì´ì§€ ë²”ìœ„ì…ë‹ˆë‹¤.');
                return;
            }

            if (glossaryStart && glossaryEnd && (glossaryStart < 1 || glossaryEnd > currentPDF.pdf.numPages || glossaryStart > glossaryEnd)) {
                alert('âŒ ì˜ëª»ëœ Glossary í˜ì´ì§€ ë²”ìœ„ì…ë‹ˆë‹¤.');
                return;
            }

            // Store PDF object locally before closing modal
            const pdfObject = currentPDF.pdf;
            const fileName = currentPDF.fileName;

            // Close modal
            closePDFSettings();

            try {
                alert(`ğŸ“„ PDF ì²˜ë¦¬ ì¤‘...\n\níŒŒì‹± ë²”ìœ„: ${parseStart} ~ ${parseEnd}\nGlossary ë²”ìœ„: ${glossaryStart && glossaryEnd ? `${glossaryStart} ~ ${glossaryEnd}` : 'ìë™ íƒì§€'}\n\ní…ìŠ¤íŠ¸ ì¶”ì¶œ ë° ë¶„ì„ì„ ì‹œì‘í•©ë‹ˆë‹¤.`);

                // Extract glossary text with proper line breaks
                let glossaryText = '';
                if (glossaryStart && glossaryEnd) {
                    for (let i = glossaryStart; i <= glossaryEnd; i++) {
                        const page = await pdfObject.getPage(i);
                        const textContent = await page.getTextContent();
                        const pageText = extractTextWithLineBreaks(textContent);
                        glossaryText += pageText + '\n';
                    }
                    glossaryTerms = extractGlossaryFromText(glossaryText);
                } else {
                    // Extract all text first to find glossary
                    let fullText = '';
                    for (let i = 1; i <= pdfObject.numPages; i++) {
                        const page = await pdfObject.getPage(i);
                        const textContent = await page.getTextContent();
                        const pageText = extractTextWithLineBreaks(textContent);
                        fullText += pageText + '\n';
                    }
                    glossaryTerms = extractGlossaryFromPDF(fullText);
                }

                // Extract text from specified page range with proper line breaks
                let contentText = '';
                for (let i = parseStart; i <= parseEnd; i++) {
                    const page = await pdfObject.getPage(i);
                    const textContent = await page.getTextContent();
                    const pageText = extractTextWithLineBreaks(textContent);
                    contentText += pageText + '\n';
                }

                // Parse paragraphs from content
                const paragraphs = parsePDFIntoParagraphs(contentText);

                // Initialize doctrine data
                doctrineData = {
                    doc_title: fileName.replace('.pdf', ''),
                    issuing_org: "PDF Upload",
                    paragraphs: paragraphs
                };

                loadParagraphList();

                if (paragraphs.length > 0) {
                    loadParagraph(paragraphs[0]);
                    document.querySelector('.paragraph-item').classList.add('active');
                }

                alert(`âœ… PDF ì²˜ë¦¬ ì™„ë£Œ!\n\nğŸ“ ë‹¨ë½: ${paragraphs.length}ê°œ\nğŸ”‘ Glossary ìš©ì–´: ${glossaryTerms.length}ê°œ`);
            } catch (error) {
                alert('âŒ PDF ì²˜ë¦¬ ì˜¤ë¥˜: ' + error.message);
                console.error('PDF Error:', error);
            }
        }

        // Extract Glossary from specific text
        function extractGlossaryFromText(text) {
            const terms = [];

            // Extract Acronyms
            const acronymPattern = /\b([A-Z]{2,})\s*[-â€“â€”]\s*([^\n]+)/g;
            let match;
            while ((match = acronymPattern.exec(text)) !== null) {
                terms.push({
                    term: match[1].trim(),
                    definition: match[2].trim(),
                    type: 'acronym'
                });
            }

            // Extract Terms
            const termPattern = /\b([a-z][a-z\s]+)\s*[-â€“â€”]\s*([^\n]+)/gi;
            while ((match = termPattern.exec(text)) !== null) {
                const term = match[1].trim();
                if (term.length > 3 && !terms.find(t => t.term.toLowerCase() === term.toLowerCase())) {
                    terms.push({
                        term: term,
                        definition: match[2].trim(),
                        type: 'term'
                    });
                }
            }

            console.log(`Extracted ${terms.length} glossary terms from specified range`);
            return terms.length > 0 ? terms : getDefaultMilitaryTerms();
        }

        // Extract Glossary from PDF
        function extractGlossaryFromPDF(text) {
            const terms = [];

            // Find Glossary section
            const glossaryMatch = text.match(/Glossary[\s\S]*?(?=\n\n[A-Z][a-z]+\s+[A-Z]|$)/i);
            if (!glossaryMatch) {
                console.log('No glossary found, using default military terms');
                return getDefaultMilitaryTerms();
            }

            const glossaryText = glossaryMatch[0];

            // Extract Acronyms (usually in format: "ATP - Army Techniques Publication")
            const acronymPattern = /\b([A-Z]{2,})\s*[-â€“â€”]\s*([^\n]+)/g;
            let match;
            while ((match = acronymPattern.exec(glossaryText)) !== null) {
                terms.push({
                    term: match[1].trim(),
                    definition: match[2].trim(),
                    type: 'acronym'
                });
            }

            // Extract Terms (usually in format: "defense - the act of...")
            const termPattern = /\b([a-z][a-z\s]+)\s*[-â€“â€”]\s*([^\n]+)/gi;
            while ((match = termPattern.exec(glossaryText)) !== null) {
                const term = match[1].trim();
                if (term.length > 3 && !terms.find(t => t.term.toLowerCase() === term.toLowerCase())) {
                    terms.push({
                        term: term,
                        definition: match[2].trim(),
                        type: 'term'
                    });
                }
            }

            console.log(`Extracted ${terms.length} glossary terms`);
            return terms.length > 0 ? terms : getDefaultMilitaryTerms();
        }

        // Default military terms if no glossary found
        function getDefaultMilitaryTerms() {
            return [
                { term: 'ATP', definition: 'Army Techniques Publication', type: 'acronym' },
                { term: 'FM', definition: 'Field Manual', type: 'acronym' },
                { term: 'defense', definition: 'defensive operations', type: 'term' },
                { term: 'attack', definition: 'offensive operations', type: 'term' },
                { term: 'enemy', definition: 'hostile force', type: 'term' },
                { term: 'force', definition: 'military unit', type: 'term' },
                { term: 'terrain', definition: 'ground area', type: 'term' },
                { term: 'obstacle', definition: 'barrier', type: 'term' }
            ];
        }

        // Extract text from PDF with line breaks preserved
        function extractTextWithLineBreaks(textContent) {
            let lastY = null;
            let text = '';

            textContent.items.forEach((item, index) => {
                // Add line break if Y position changed significantly
                if (lastY !== null && Math.abs(item.transform[5] - lastY) > 5) {
                    text += '\n';
                }
                text += item.str;

                // Add space if next item is on same line
                if (index < textContent.items.length - 1) {
                    const nextItem = textContent.items[index + 1];
                    if (Math.abs(item.transform[5] - nextItem.transform[5]) < 5) {
                        text += ' ';
                    }
                }

                lastY = item.transform[5];
            });

            return text;
        }

        // Parse PDF text into paragraphs with hierarchy
        function parsePDFIntoParagraphs(text) {
            const paragraphs = [];
            let currentChapter = null;
            let currentSection = null;
            let currentTopic = null;
            let currentPoint = null;
            let currentDetail = null;

            const lines = text.split('\n');
            let i = 0;

            while (i < lines.length) {
                const line = lines[i].trim();

                // [FILTER] Skip Empty Lines
                if (!line) {
                    i++;
                    continue;
                }

                // [FILTER] Skip Page Headers/Footers (Page numbers like "1-1", "35")
                if (line.match(/^\d+-\d+$/) || line.match(/^\d+$/)) {
                    i++;
                    continue;
                }
                // [FILTER] Skip Document Metadata repeated on pages
                if (line.includes('ATP 3-21.20') || line.includes('28 December 2017')) {
                    i++;
                    continue;
                }

                // 1. Chapter Detection
                const chapterMatch = line.match(/^CHAPTER\s+(\d+)\s*(.*)$/i);
                if (chapterMatch) {
                    const newChapterNum = chapterMatch[1];
                    const hasTitleInLine = chapterMatch[2] && chapterMatch[2].trim().length > 0;

                    // Only reset children if it's a NEW chapter
                    if (!currentChapter || currentChapter.number !== newChapterNum) {
                        currentSection = null;
                        currentTopic = null;
                        currentPoint = null;
                        currentDetail = null;
                    }

                    currentChapter = {
                        number: newChapterNum,
                        title: hasTitleInLine ? chapterMatch[2].trim() : (lines[i + 1] ? lines[i + 1].trim() : '')
                    };

                    i += hasTitleInLine ? 1 : 2;
                    continue;
                }

                // 2. Section Detection
                const sectionMatch = line.match(/^SECTION\s+([IVX\d]+)(?:\s*[-â€”â€“]\s*(.*))?$/i);
                if (sectionMatch) {
                    const newSectionNum = sectionMatch[1];
                    const hasTitleInLine = sectionMatch[2] && sectionMatch[2].trim().length > 0;

                    // Only reset children if it's a NEW section
                    if (!currentSection || currentSection.number !== newSectionNum) {
                        currentTopic = null;
                        currentPoint = null;
                        currentDetail = null;
                    }

                    currentSection = {
                        number: newSectionNum,
                        title: hasTitleInLine ? sectionMatch[2].trim() : (lines[i + 1] ? lines[i + 1].trim() : '')
                    };

                    i += hasTitleInLine ? 1 : 2;
                    continue;
                }

                // 3. Paragraph Detection (e.g., "1-1. Title")
                const paraMatch = line.match(/^(\d+-\d+)[.\s]+(.*)$/);
                if (paraMatch) {
                    const paraNumber = paraMatch[1];
                    let paraTitle = paraMatch[2].trim();

                    if (!paraTitle && i + 1 < lines.length) {
                        paraTitle = lines[i + 1].trim();
                        i++;
                    }

                    const contentLines = [];
                    // Add title to content text because it often contains the first sentence
                    if (paraTitle) {
                        contentLines.push(paraTitle);
                    }

                    i++;
                    while (i < lines.length) {
                        const nextLine = lines[i].trim();

                        // [FILTER] Skip Headers inside content
                        if (nextLine.match(/^\d+-\d+$/) || nextLine.match(/^\d+$/) ||
                            nextLine.includes('ATP 3-21.20') || nextLine.includes('28 December 2017')) {
                            i++;
                            continue;
                        }

                        // Stop if we hit a new structure marker
                        if (nextLine.match(/^\d+-\d+[.\s]+/) ||
                            nextLine.match(/^CHAPTER\s+\d+/i) ||
                            nextLine.match(/^SECTION\s+[IVX\d]+/i) ||
                            // Heuristic for headers: short line, no para number, no period at end
                            (!nextLine.match(/^\d+/) && nextLine.length < 50 && !nextLine.endsWith('.'))) {
                            break;
                        }
                        if (nextLine) {
                            contentLines.push(nextLine);
                        }
                        i++;
                    }

                    const content = contentLines.join(' ').trim();

                    if (content.length > 30) {
                        const sentences = parseSentences(content);
                        const keywords = extractKeywordsFromGlossary(content, sentences);
                        const claims = generateClaims(sentences);
                        const references = extractReferences(content, sentences);

                        paragraphs.push({
                            paragraph_number: paraNumber,
                            paragraph_title: paraTitle.toLowerCase(),
                            raw_text: content,
                            sentences: sentences,
                            keywords: keywords,
                            claims: claims,
                            references: references,
                            summary: {
                                text_ko: generateSummary(sentences),
                                evidence_sids: sentences.slice(0, Math.min(3, sentences.length)).map(s => s.id)
                            },
                            metadata: {
                                chapter: currentChapter ? currentChapter.title : null,
                                chapter_number: currentChapter ? currentChapter.number : null,
                                section: currentSection ? currentSection.title : null,
                                section_number: currentSection ? currentSection.number : null,
                                topic: currentTopic, // From All Caps header
                                point: currentPoint, // Not explicitly distinguished yet
                                detail: currentDetail || null // From Title Case header
                            }
                        });
                    }
                    continue;
                }

                // 4. Intermediate Header Detection
                // Condition: Short line (< 80 chars), not a number, no ending period
                if (line.length < 80 && !line.match(/^\d+/) && !line.endsWith('.')) {

                    // Determine Type based on Casing
                    const isAllCaps = line === line.toUpperCase() && /[A-Z]/.test(line);

                    if (isAllCaps) {
                        // -> POINT
                        // User correction: Blue boxes (ALL CAPS) are "Point" level, not Topic.
                        // Topic level seems to be skipped or implicit in this document structure.
                        currentTopic = null; // Reset Topic as we are now at Point level directly (or Topic is unused)
                        currentPoint = line;

                        // Reset Detail whenever a higher level header is found
                        currentDetail = null;
                    } else {
                        // -> DETAIL (Title Case / Mixed Case)
                        // Green boxes are "Detail" level.
                        currentDetail = line;
                    }
                    i++;
                    continue;
                }

                i++;
            }

            console.log(`Parsed ${paragraphs.length} paragraphs with hierarchy`);
            return paragraphs;
        }

        // Extract keywords using Glossary terms
        function extractKeywordsFromGlossary(text, sentences) {
            const keywords = [];
            const colors = ['#4CAF50', '#2196F3', '#FF9800', '#9C27B0', '#F44336', '#00BCD4', '#FFEB3B', '#795548', '#607D8B', '#E91E63', '#3F51B5', '#8BC34A', '#FFC107', '#009688'];
            let colorIndex = 0;
            const foundTerms = new Set();

            // Use glossary terms
            glossaryTerms.forEach(glossaryItem => {
                const term = glossaryItem.term;
                const termLower = term.toLowerCase();

                if (!foundTerms.has(termLower)) {
                    // Check if term appears in text
                    const regex = new RegExp(`\\b${escapeRegex(term)}\\b`, 'gi');
                    if (regex.test(text)) {
                        foundTerms.add(termLower);

                        const evidence_sids = sentences
                            .filter(s => new RegExp(`\\b${escapeRegex(term)}\\b`, 'i').test(s.text))
                            .map(s => s.id);

                        if (evidence_sids.length > 0) {
                            keywords.push({
                                keyword: term,
                                evidence_sids: evidence_sids,
                                color: colors[colorIndex % colors.length],
                                definition: glossaryItem.definition
                            });
                            colorIndex++;
                        }
                    }
                }
            });

            // If no glossary matches, fall back to pattern matching
            if (keywords.length === 0) {
                return extractKeywords(text, sentences);
            }

            return keywords.slice(0, 20); // Limit to 20 keywords
        }

        function escapeRegex(string) {
            return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
        }

        // Toggle text input modal
        function toggleTextInput() {
            const modal = document.getElementById('textInputModal');
            modal.style.display = modal.style.display === 'none' ? 'block' : 'none';

            if (modal.style.display === 'block') {
                document.getElementById('paraNumber').value = '';
                document.getElementById('paraTitle').value = '';
                document.getElementById('paraText').value = '';
            }
        }

        // Parse text and add paragraph
        function parseAndAddParagraph() {
            const number = document.getElementById('paraNumber').value.trim();
            const title = document.getElementById('paraTitle').value.trim();
            const text = document.getElementById('paraText').value.trim();

            if (!number || !title || !text) {
                alert('âŒ ëª¨ë“  í•„ë“œë¥¼ ì…ë ¥í•´ì£¼ì„¸ìš”!');
                return;
            }

            // Parse text into sentences
            const sentences = parseSentences(text);

            // Auto-extract keywords
            const keywords = extractKeywords(text, sentences);

            // Auto-generate claims
            const claims = generateClaims(sentences);

            // Extract references
            const references = extractReferences(text, sentences);

            // Create paragraph object
            const newParagraph = {
                paragraph_number: number,
                paragraph_title: title,
                raw_text: text,
                sentences: sentences,
                keywords: keywords,
                claims: claims,
                references: extractReferences(text, sentences),
                summary: {
                    text_ko: generateSummary(sentences),
                    evidence_sids: sentences.slice(0, Math.min(3, sentences.length)).map(s => s.id)
                }
            };

            // Initialize or update doctrine data
            if (!doctrineData) {
                doctrineData = {
                    doc_title: "Custom Doctrine",
                    issuing_org: "User Input",
                    paragraphs: []
                };
            }

            doctrineData.paragraphs.push(newParagraph);
            loadParagraphList();

            // Auto-select the new paragraph
            loadParagraph(newParagraph);
            const items = document.querySelectorAll('.paragraph-item');
            items.forEach(item => item.classList.remove('active'));
            items[items.length - 1].classList.add('active');

            toggleTextInput();
            saveProgress();
            alert('âœ… ë‹¨ë½ì´ ì¶”ê°€ë˜ì—ˆìŠµë‹ˆë‹¤!\n\nğŸ“ ë¬¸ì¥: ' + sentences.length + 'ê°œ\nğŸ”‘ í‚¤ì›Œë“œ: ' + keywords.length + 'ê°œ\nâ­ Claims: ' + claims.length + 'ê°œ\nğŸ”— References: ' + references.length + 'ê°œ');
        }

        // Parse text into sentences
        function parseSentences(text) {
            // Split by period, exclamation, or question mark followed by space or end
            const sentenceRegex = /[^.!?]+[.!?]+/g;
            const rawSentences = text.match(sentenceRegex) || [text];

            return rawSentences.map((sentence, index) => ({
                id: `S${index + 1}`,
                text: sentence.trim(),
                completed: false
            }));
        }

        // Extract references from text
        function extractReferences(text, sentences) {
            const references = [];
            const foundRefs = new Set(); // Avoid duplicates

            // 1. Paragraph references - multiple patterns
            const paraPatterns = [
                /see paragraphs? ([\d-]+(?:,?\s*[\d-]+)*)/gi,  // "see paragraphs 3-193" or "see paragraph 3-193, 4-5"
                /refer to paragraphs? ([\d-]+(?:,?\s*[\d-]+)*)/gi,
                /\(paragraphs? ([\d-]+(?:,?\s*[\d-]+)*)\)/gi,
                /para(?:graph)?s?\s+([\d-]+)/gi,
                /section ([\d-]+)/gi,
                /chapter ([\d-]+)/gi
            ];

            paraPatterns.forEach(pattern => {
                let match;
                while ((match = pattern.exec(text)) !== null) {
                    const refKey = `para_${match[1]}`;
                    if (!foundRefs.has(refKey)) {
                        foundRefs.add(refKey);
                        const evidenceSids = findSentenceIds(match[0], sentences);
                        references.push({
                            ref_text: match[0],
                            ref_type: "paragraph",
                            ref_target: match[1],
                            evidence_sids: evidenceSids
                        });
                    }
                }
            });

            // 2. Figure references - multiple patterns
            const figPatterns = [
                /\(figure ([\d-]+[A-Za-z]*)\)/gi,  // "(figure 3-1)" or "(figure 3-1a)"
                /\(fig\.?\s+([\d-]+[A-Za-z]*)\)/gi,  // "(fig. 3-1)" or "(fig 3-1)"
                /figure ([\d-]+[A-Za-z]*)/gi,
                /fig\.?\s+([\d-]+[A-Za-z]*)/gi
            ];

            figPatterns.forEach(pattern => {
                let match;
                while ((match = pattern.exec(text)) !== null) {
                    const refKey = `fig_${match[1]}`;
                    if (!foundRefs.has(refKey)) {
                        foundRefs.add(refKey);
                        const evidenceSids = findSentenceIds(match[0], sentences);
                        references.push({
                            ref_text: match[0],
                            ref_type: "figure",
                            ref_target: match[1],
                            evidence_sids: evidenceSids
                        });
                    }
                }
            });

            // 3. Table references
            const tablePatterns = [
                /\(table ([\d-]+[A-Za-z]*)\)/gi,
                /\(tbl\.?\s+([\d-]+[A-Za-z]*)\)/gi,
                /table ([\d-]+[A-Za-z]*)/gi
            ];

            tablePatterns.forEach(pattern => {
                let match;
                while ((match = pattern.exec(text)) !== null) {
                    const refKey = `table_${match[1]}`;
                    if (!foundRefs.has(refKey)) {
                        foundRefs.add(refKey);
                        const evidenceSids = findSentenceIds(match[0], sentences);
                        references.push({
                            ref_text: match[0],
                            ref_type: "table",
                            ref_target: match[1],
                            evidence_sids: evidenceSids
                        });
                    }
                }
            });

            // 4. Appendix references
            const appendixPatterns = [
                /appendix ([A-Z])/gi,
                /\(appendix ([A-Z])\)/gi
            ];

            appendixPatterns.forEach(pattern => {
                let match;
                while ((match = pattern.exec(text)) !== null) {
                    const refKey = `appendix_${match[1]}`;
                    if (!foundRefs.has(refKey)) {
                        foundRefs.add(refKey);
                        const evidenceSids = findSentenceIds(match[0], sentences);
                        references.push({
                            ref_text: match[0],
                            ref_type: "appendix",
                            ref_target: match[1],
                            evidence_sids: evidenceSids
                        });
                    }
                }
            });

            // 5. ATP/FM/ADP references (military doctrine references)
            const docPatterns = [
                /(ATP|FM|ADP|ADRP|TC)\s+([\d-]+)/gi
            ];

            docPatterns.forEach(pattern => {
                let match;
                while ((match = pattern.exec(text)) !== null) {
                    const refKey = `doc_${match[0]}`;
                    if (!foundRefs.has(refKey)) {
                        foundRefs.add(refKey);
                        const evidenceSids = findSentenceIds(match[0], sentences);
                        references.push({
                            ref_text: match[0],
                            ref_type: "document",
                            ref_target: match[0],
                            evidence_sids: evidenceSids
                        });
                    }
                }
            });

            return references;
        }

        // Find which sentences contain a specific text
        function findSentenceIds(searchText, sentences) {
            return sentences
                .filter(s => s.text.includes(searchText))
                .map(s => s.id);
        }

        // Auto-extract keywords from text
        function extractKeywords(text, sentences) {
            const keywords = [];
            const colors = ['#4CAF50', '#2196F3', '#FF9800', '#9C27B0', '#F44336', '#00BCD4', '#FFEB3B', '#795548', '#607D8B', '#E91E63', '#3F51B5', '#8BC34A', '#FFC107', '#009688'];
            let colorIndex = 0;

            // Common military/tactical terms patterns
            const patterns = [
                // Tactical concepts
                /\b(defense|attack|offensive|defensive|maneuver|operation|mission|objective)\b/gi,
                /\b(force|unit|battalion|company|platoon|squad|element)\b/gi,
                /\b(enemy|hostile|threat|adversary|opposition)\b/gi,
                /\b(terrain|ground|position|location|area|zone)\b/gi,
                /\b(fire|fires|firepower|engagement|combat)\b/gi,
                /\b(command|control|commander|leadership)\b/gi,
                /\b(plan|planning|strategy|tactic|technique)\b/gi,
                /\b(support|assist|reinforce|sustain)\b/gi,
                /\b(obstacle|barrier|fortification|defense line)\b/gi,
                /\b(movement|advance|withdraw|retreat|delay)\b/gi,
                // Multi-word phrases
                /\b(linear obstacle|forward defense|engagement area|bridgehead|foothold)\b/gi,
                /\b(breaching operation|counterattack|concentrated force)\b/gi
            ];

            const foundTerms = new Set();

            patterns.forEach(pattern => {
                let match;
                while ((match = pattern.exec(text)) !== null) {
                    const term = match[0].toLowerCase();
                    if (!foundTerms.has(term) && term.length > 3) {
                        foundTerms.add(term);

                        // Find which sentences contain this term
                        const evidence_sids = sentences
                            .filter(s => s.text.toLowerCase().includes(term))
                            .map(s => s.id);

                        if (evidence_sids.length > 0) {
                            keywords.push({
                                keyword: match[0],
                                evidence_sids: evidence_sids,
                                color: colors[colorIndex % colors.length]
                            });
                            colorIndex++;
                        }
                    }
                }
            });

            // If no keywords found, extract important nouns (simple heuristic)
            if (keywords.length === 0) {
                const words = text.match(/\b[A-Z][a-z]+(?:\s+[A-Z][a-z]+)*\b/g) || [];
                const wordCounts = {};

                words.forEach(word => {
                    if (word.length > 4) {
                        wordCounts[word] = (wordCounts[word] || 0) + 1;
                    }
                });

                Object.entries(wordCounts)
                    .filter(([word, count]) => count >= 2)
                    .slice(0, 10)
                    .forEach(([word, count]) => {
                        const evidence_sids = sentences
                            .filter(s => s.text.includes(word))
                            .map(s => s.id);

                        keywords.push({
                            keyword: word,
                            evidence_sids: evidence_sids,
                            color: colors[colorIndex % colors.length]
                        });
                        colorIndex++;
                    });
            }

            return keywords.slice(0, 15); // Limit to 15 keywords
        }

        // Auto-generate claims from sentences
        function generateClaims(sentences) {
            const claims = [];

            // Strategy: Group related sentences into claims
            // For simplicity, create one claim per 2-3 sentences
            const groupSize = Math.ceil(sentences.length / Math.max(2, Math.floor(sentences.length / 3)));

            for (let i = 0; i < sentences.length; i += groupSize) {
                const group = sentences.slice(i, i + groupSize);
                const evidence_sids = group.map(s => s.id);

                // Create a simple claim by combining sentence texts
                const claimText = group.map(s => s.text).join(' ').substring(0, 200) + '...';

                claims.push({
                    claim: `í•µì‹¬ ${claims.length + 1}: ${claimText}`,
                    evidence_sids: evidence_sids,
                    completed: false
                });
            }

            // If only one sentence, create at least one claim
            if (claims.length === 0 && sentences.length > 0) {
                claims.push({
                    claim: `í•µì‹¬: ${sentences[0].text}`,
                    evidence_sids: [sentences[0].id],
                    completed: false
                });
            }

            return claims;
        }

        // Auto-generate summary
        function generateSummary(sentences) {
            if (sentences.length === 0) return "ë‚´ìš©ì´ ì—†ìŠµë‹ˆë‹¤.";

            // Simple summary: first sentence + last sentence
            if (sentences.length === 1) {
                return sentences[0].text;
            } else if (sentences.length === 2) {
                return sentences[0].text + ' ' + sentences[1].text;
            } else {
                return `${sentences[0].text} ... ${sentences[sentences.length - 1].text}`;
            }
        }

        // Tab switching
        document.querySelectorAll('.tab').forEach(tab => {
            tab.addEventListener('click', () => {
                const tabName = tab.dataset.tab;

                // Update tab buttons
                document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
                tab.classList.add('active');

                // Update tab content
                document.querySelectorAll('.tab-content').forEach(content => {
                    content.classList.remove('active');
                });
                document.getElementById(tabName).classList.add('active');
            });
        });

        // File upload
        document.getElementById('jsonUpload').addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = (event) => {
                try {
                    doctrineData = JSON.parse(event.target.result);
                    loadParagraphList();
                    alert('âœ… Doctrine loaded successfully!');
                } catch (error) {
                    alert('âŒ Error loading JSON: ' + error.message);
                }
            };
            reader.readAsText(file);
        });

        function loadParagraphList() {
            const list = document.getElementById('paragraphList');
            list.innerHTML = '';

            doctrineData.paragraphs.forEach((para, index) => {
                const item = document.createElement('div');
                item.className = 'paragraph-item';

                const completedSentences = para.sentences.filter(s => s.completed).length;
                const totalSentences = para.sentences.length;
                const progress = totalSentences > 0 ? (completedSentences / totalSentences * 100) : 0;

                // Metadata
                const keywordCount = para.keywords ? para.keywords.length : 0;
                const claimCount = para.claims ? para.claims.length : 0;
                const refCount = para.references ? para.references.length : 0;

                const metadata = `ğŸ“ ${totalSentences}ë¬¸ì¥ | ğŸ”‘ ${keywordCount}í‚¤ì›Œë“œ | â­ ${claimCount}Claims | ğŸ”— ${refCount}ì°¸ì¡°`;

                item.innerHTML = `
                    <div class="number">${para.paragraph_number}</div>
                    <div class="title" style="font-size: 0.75rem; color: #888; margin-top: 4px;">${metadata}</div>
                    <div class="progress">
                        <div class="progress-bar" style="width: ${progress}%"></div>
                    </div>
                `;

                // Tooltip with full title
                item.title = `${para.paragraph_number}: ${para.paragraph_title}\n\n${metadata}`;

                item.addEventListener('click', () => {
                    document.querySelectorAll('.paragraph-item').forEach(i => i.classList.remove('active'));
                    item.classList.add('active');
                    loadParagraph(para);
                });

                list.appendChild(item);
            });
        }

        function loadParagraph(para) {
            currentParagraph = para;

            // Update header
            document.getElementById('mainTitle').textContent = `${para.paragraph_number}: ${para.paragraph_title}`;
            document.getElementById('mainSubtitle').textContent = doctrineData.doc_title;
            document.getElementById('progressSummary').style.display = 'flex';

            // Load all tabs
            loadSentencesTab(para);
            loadKeywordsTab(para);
            loadClaimsTab(para);
            loadReferencesTab(para);
            loadMetadataTab(para);
            loadSummaryTab(para);

            updateProgress(para);
        }

        function loadSentencesTab(para) {
            const container = document.getElementById('sentences');
            container.innerHTML = '';

            para.sentences.forEach(sentence => {
                const item = document.createElement('div');
                item.className = `sentence-item ${sentence.completed ? 'completed' : ''}`;
                item.id = `sentence-${sentence.id}`;

                const highlightedText = highlightKeywords(sentence.text, para.keywords);

                item.innerHTML = `
                    <div class="sentence-header">
                        <input type="checkbox" class="sentence-checkbox" ${sentence.completed ? 'checked' : ''}>
                        <span class="sentence-id">${sentence.id}</span>
                        <span class="sentence-text ${sentence.completed ? 'completed' : ''}">${highlightedText}</span>
                    </div>
                `;

                const checkbox = item.querySelector('.sentence-checkbox');
                checkbox.addEventListener('change', () => {
                    sentence.completed = checkbox.checked;
                    item.classList.toggle('completed', checkbox.checked);
                    item.querySelector('.sentence-text').classList.toggle('completed', checkbox.checked);
                    updateProgress(para);
                    saveProgress();
                });

                container.appendChild(item);
            });
        }

        function loadKeywordsTab(para) {
            const container = document.getElementById('keywords');
            container.innerHTML = '';

            para.keywords.forEach(kw => {
                const item = document.createElement('div');
                item.className = 'keyword-item';

                const badges = kw.evidence_sids.map(sid =>
                    `<span class="keyword-badge">${sid}</span>`
                ).join('');

                item.innerHTML = `
                    <div class="keyword-color" style="background: ${kw.color}"></div>
                    <div class="keyword-text">${kw.keyword}</div>
                    <div class="keyword-badges">${badges}</div>
                `;

                item.addEventListener('click', () => {
                    // Switch to sentences tab and highlight
                    document.querySelector('[data-tab="sentences"]').click();
                    setTimeout(() => {
                        const firstSid = kw.evidence_sids[0];
                        const element = document.getElementById(`sentence-${firstSid}`);
                        if (element) {
                            element.scrollIntoView({ behavior: 'smooth', block: 'center' });
                            element.style.background = '#3a3a3a';
                            setTimeout(() => {
                                element.style.background = '';
                            }, 2000);
                        }
                    }, 100);
                });

                container.appendChild(item);
            });
        }

        function loadClaimsTab(para) {
            const container = document.getElementById('claims');
            container.innerHTML = '';

            para.claims.forEach((claim, index) => {
                const item = document.createElement('div');
                item.className = `claim-item ${claim.completed ? 'completed' : ''}`;

                const evidenceBadges = claim.evidence_sids.map(sid =>
                    `<span class="evidence-badge" onclick="jumpToSentence('${sid}')">${sid}</span>`
                ).join('');

                item.innerHTML = `
                    <div class="claim-header">
                        <input type="checkbox" class="claim-checkbox" ${claim.completed ? 'checked' : ''}>
                        <div class="claim-text">${claim.claim}</div>
                    </div>
                    <div class="claim-evidence">
                        Evidence: ${evidenceBadges}
                    </div>
                `;

                const checkbox = item.querySelector('.claim-checkbox');
                checkbox.addEventListener('change', () => {
                    claim.completed = checkbox.checked;
                    item.classList.toggle('completed', checkbox.checked);
                    updateProgress(para);
                    saveProgress();
                });

                container.appendChild(item);
            });
        }

        function loadReferencesTab(para) {
            const container = document.getElementById('references');

            if (!para.references || para.references.length === 0) {
                container.innerHTML = '<div class="empty-state"><h3>No references in this paragraph</h3></div>';
                return;
            }

            container.innerHTML = '';

            para.references.forEach(ref => {
                const item = document.createElement('div');
                item.className = 'reference-item';

                const evidenceBadges = ref.evidence_sids.map(sid =>
                    `<span class="evidence-badge" onclick="jumpToSentence('${sid}')">${sid}</span>`
                ).join('');

                item.innerHTML = `
                    <div class="reference-type">${ref.ref_type}</div>
                    <a class="reference-link">${ref.ref_text}</a>
                    <div class="reference-evidence">
                        Mentioned in: ${evidenceBadges}
                    </div>
                `;

                item.querySelector('.reference-link').addEventListener('click', () => {
                    if (ref.ref_type === 'paragraph') {
                        alert(`Navigate to paragraph ${ref.ref_target}\n(Cross-reference navigation will be implemented when full doctrine is loaded)`);
                    } else if (ref.ref_type === 'figure') {
                        alert(`Open figure ${ref.ref_target}\n(Figure viewer will be implemented in future version)`);
                    }
                });

                container.appendChild(item);
            });
        }

        function loadMetadataTab(para) {
            const container = document.getElementById('metadata');

            // Format metadata fields
            const chapterInfo = para.metadata && para.metadata.chapter ?
                `${para.metadata.chapter_number ? `Chapter ${para.metadata.chapter_number}: ` : ''}${para.metadata.chapter}` :
                '(No Chapter info)';

            const sectionInfo = para.metadata && para.metadata.section ?
                `${para.metadata.section_number ? `Section ${para.metadata.section_number}: ` : ''}${para.metadata.section}` :
                '(No Section info)';

            const topicInfo = para.metadata && para.metadata.topic ? para.metadata.topic : '(null)';
            const pointInfo = para.metadata && para.metadata.point ? para.metadata.point : '(null)';
            const detailInfo = para.metadata && para.metadata.detail ? para.metadata.detail : '(null)';

            container.innerHTML = `
                <div class="metadata-content" style="padding: 20px;">
                    <h3 style="color: var(--accent-orange); border-bottom: 2px solid var(--border-color); padding-bottom: 10px; margin-bottom: 20px;">
                        â„¹ï¸ Paragraph Metadata
                    </h3>
                    
                    <div style="display: grid; grid-template-columns: 1fr; gap: 15px;">
                        <div class="meta-item" style="background: var(--bg-dark); padding: 15px; border-radius: 8px; border: 1px solid var(--border-color);">
                            <div style="color: var(--text-secondary); font-size: 0.9rem; margin-bottom: 5px;">Document Title</div>
                            <div style="color: var(--text-primary); font-weight: 500;">${doctrineData.doc_title || 'Unknown Document'}</div>
                        </div>

                        <div class="meta-item" style="background: var(--bg-dark); padding: 15px; border-radius: 8px; border: 1px solid var(--border-color);">
                            <div style="color: var(--text-secondary); font-size: 0.9rem; margin-bottom: 5px;">Issuing Organization</div>
                            <div style="color: var(--text-primary); font-weight: 500;">${doctrineData.issuing_org || 'HEADQUARTERS, DEPARTMENT OF THE ARMY'}</div>
                        </div>

                        <div class="meta-item" style="background: var(--bg-dark); padding: 15px; border-radius: 8px; border: 1px solid var(--border-color);">
                            <div style="color: var(--text-secondary); font-size: 0.9rem; margin-bottom: 5px;">Edition / Revision</div>
                            <div style="color: var(--text-primary); font-weight: 500;">${doctrineData.edition || 'null'}</div>
                        </div>

                        <div class="meta-section" style="margin-top: 10px; border-top: 1px dashed var(--border-color); padding-top: 20px;">
                            <div style="background: var(--bg-dark); padding: 15px; border-radius: 8px; border: 1px solid var(--border-color); margin-bottom: 10px;">
                                <div style="color: var(--accent-blue); font-size: 0.9rem; margin-bottom: 5px;">ğŸ“‚ Chapter</div>
                                <div style="color: var(--text-primary); font-weight: 600;">${chapterInfo}</div>
                            </div>

                            <div style="background: var(--bg-dark); padding: 15px; border-radius: 8px; border: 1px solid var(--border-color); margin-bottom: 10px;">
                                <div style="color: var(--accent-blue); font-size: 0.9rem; margin-bottom: 5px;">ğŸ“‘ Section</div>
                                <div style="color: var(--text-primary); font-weight: 600;">${sectionInfo}</div>
                            </div>

                            <div style="background: var(--bg-dark); padding: 15px; border-radius: 8px; border: 1px solid var(--border-color); margin-bottom: 10px;">
                                <div style="color: var(--accent-blue); font-size: 0.9rem; margin-bottom: 5px;">ğŸ“Œ Topic</div>
                                <div style="color: var(--text-primary); font-weight: 600;">${topicInfo}</div>
                            </div>
                            
                            <div style="background: var(--bg-dark); padding: 15px; border-radius: 8px; border: 1px solid var(--border-color); margin-bottom: 10px;">
                                <div style="color: var(--accent-blue); font-size: 0.9rem; margin-bottom: 5px;">ğŸ“ Point</div>
                                <div style="color: var(--text-primary); font-weight: 600;">${pointInfo}</div>
                            </div>

                            <div style="background: var(--bg-dark); padding: 15px; border-radius: 8px; border: 1px solid var(--border-color);">
                                <div style="color: var(--accent-blue); font-size: 0.9rem; margin-bottom: 5px;">ğŸ“„ Detail (Brief Title)</div>
                                <div style="color: var(--text-primary); font-weight: 600;">${detailInfo}</div>
                            </div>
                        </div>
                    </div>
                </div>
            `;
        }

        function loadSummaryTab(para) {
            const container = document.getElementById('summary');

            if (!para.summary) {
                container.innerHTML = '<div class="empty-state"><h3>No summary available</h3></div>';
                return;
            }

            const evidenceBadges = para.summary.evidence_sids ?
                para.summary.evidence_sids.map(sid =>
                    `<span class="evidence-badge" onclick="jumpToSentence('${sid}')">${sid}</span>`
                ).join('') : '';

            container.innerHTML = `
                <div class="summary-content">
                    <h3>ğŸ“„ Summary (Korean)</h3>
                    <p>${para.summary.text_ko}</p>
                    ${evidenceBadges ? `<div style="margin-top: 20px; font-size: 0.85rem; color: var(--text-secondary);">Key sentences: ${evidenceBadges}</div>` : ''}
                </div>
            `;
        }

        function highlightKeywords(text, keywords) {
            let result = text;

            // Sort keywords by length (longest first) to avoid partial matches
            const sortedKeywords = [...keywords].sort((a, b) => b.keyword.length - a.keyword.length);

            sortedKeywords.forEach(kw => {
                const regex = new RegExp(`(${escapeRegex(kw.keyword)})`, 'gi');
                result = result.replace(regex, `<span class="highlight" style="background: ${kw.color}33; color: ${kw.color}">$1</span>`);
            });

            return result;
        }

        function escapeRegex(string) {
            return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
        }

        function jumpToSentence(sid) {
            document.querySelector('[data-tab="sentences"]').click();
            setTimeout(() => {
                const element = document.getElementById(`sentence-${sid}`);
                if (element) {
                    element.scrollIntoView({ behavior: 'smooth', block: 'center' });
                    element.style.background = '#3a3a3a';
                    setTimeout(() => {
                        element.style.background = '';
                    }, 2000);
                }
            }, 100);
        }

        function updateProgress(para) {
            const completedSentences = para.sentences.filter(s => s.completed).length;
            const totalSentences = para.sentences.length;
            const completedClaims = para.claims.filter(c => c.completed).length;
            const totalClaims = para.claims.length;

            const overallProgress = totalSentences > 0 ?
                Math.round((completedSentences / totalSentences) * 100) : 0;

            document.getElementById('sentenceProgress').textContent = `${completedSentences}/${totalSentences}`;
            document.getElementById('claimProgress').textContent = `${completedClaims}/${totalClaims}`;
            document.getElementById('overallProgress').textContent = `${overallProgress}%`;

            // Update sidebar progress
            loadParagraphList();
        }

        function saveProgress() {
            if (doctrineData) {
                localStorage.setItem('doctrine_progress', JSON.stringify(doctrineData));
            }
        }

        function loadProgress() {
            const saved = localStorage.getItem('doctrine_progress');
            if (saved) {
                try {
                    doctrineData = JSON.parse(saved);
                    loadParagraphList();
                } catch (e) {
                    console.error('Error loading saved progress:', e);
                }
            }
        }

        // Show Glossary Modal
        function showGlossaryModal() {
            const modal = document.getElementById('glossaryModal');
            const content = document.getElementById('glossaryListContent');

            if (glossaryTerms.length === 0) {
                content.innerHTML = '<div style="padding: 20px; text-align: center; color: var(--text-secondary);">No glossary terms extracted yet.</div>';
            } else {
                renderGlossaryList(glossaryTerms);
            }

            modal.style.display = 'block';
        }

        // Render Glossary List
        function renderGlossaryList(terms) {
            const content = document.getElementById('glossaryListContent');
            content.innerHTML = '';

            // Sort alphabetical
            const sortedTerms = [...terms].sort((a, b) => a.term.localeCompare(b.term));

            sortedTerms.forEach(term => {
                const item = document.createElement('div');
                item.style.padding = '15px';
                item.style.borderBottom = '1px solid var(--border-color)';
                item.innerHTML = `
                    <div style="display: flex; align-items: baseline; gap: 10px; margin-bottom: 5px;">
                        <span style="color: var(--accent-orange); font-weight: 600; font-size: 1.1rem;">${term.term}</span>
                        <span style="font-size: 0.8rem; padding: 2px 6px; border-radius: 4px; background: ${term.type === 'acronym' ? 'rgba(76, 175, 80, 0.2)' : 'rgba(33, 150, 243, 0.2)'}; color: ${term.type === 'acronym' ? '#4CAF50' : '#2196F3'};">${term.type}</span>
                    </div>
                    <div style="color: var(--text-primary); line-height: 1.5;">${term.definition}</div>
                `;
                content.appendChild(item);
            });
        }

        // Filter Glossary
        function filterGlossary() {
            const query = document.getElementById('glossarySearch').value.toLowerCase();
            const filtered = glossaryTerms.filter(t =>
                t.term.toLowerCase().includes(query) ||
                t.definition.toLowerCase().includes(query)
            );
            renderGlossaryList(filtered);
        }

        // Auto-load sample data on startup
        window.addEventListener('load', () => {
            fetch('sample-doctrine.json')
                .then(response => response.json())
                .then(data => {
                    doctrineData = data;
                    loadParagraphList();
                    // Auto-select first paragraph
                    if (data.paragraphs.length > 0) {
                        loadParagraph(data.paragraphs[0]);
                        document.querySelector('.paragraph-item').classList.add('active');
                    }
                })
                .catch(error => {
                    console.log('Sample data not found, waiting for user upload');
                });
        });
    </script>
</body>

</html>